package checks

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/cloudflare/pint/internal/discovery"
	"github.com/cloudflare/pint/internal/parser"
	"github.com/cloudflare/pint/internal/parser/utils"
)

const (
	RuleDependencyCheckName = "rule/dependency"
)

func NewRuleDependencyCheck() RuleDependencyCheck {
	return RuleDependencyCheck{}
}

type RuleDependencyCheck struct{}

func (c RuleDependencyCheck) Meta() CheckMeta {
	return CheckMeta{
		States: []discovery.ChangeType{
			discovery.Removed,
		},
		IsOnline: false,
	}
}

func (c RuleDependencyCheck) String() string {
	return RuleDependencyCheckName
}

func (c RuleDependencyCheck) Reporter() string {
	return RuleDependencyCheckName
}

func (c RuleDependencyCheck) Check(_ context.Context, path string, rule parser.Rule, entries []discovery.Entry) (problems []Problem) {
	if rule.RecordingRule == nil {
		return problems
	}

	var broken []brokenDependency
	for _, entry := range entries {
		if entry.State == discovery.Removed {
			continue
		}
		if entry.PathError != nil {
			continue
		}
		if entry.Rule.Error.Err != nil {
			continue
		}
		if c.usesVector(entry, rule.RecordingRule.Record.Value.Value) {
			expr := entry.Rule.Expr()
			dep := brokenDependency{
				path: entry.ReportedPath,
				line: expr.Lines()[0],
				name: entry.Rule.Name(),
			}
			var found bool
			for _, b := range broken {
				if b.path == dep.path && b.line == dep.line && b.name == dep.name {
					found = true
					break
				}
			}
			if !found {
				broken = append(broken, dep)
			}
		}
	}

	if len(broken) == 0 {
		return problems
	}

	sort.Slice(broken, func(i, j int) bool {
		if broken[i].path != broken[j].path {
			return broken[i].path < broken[j].path
		}
		if broken[i].line != broken[j].line {
			return broken[i].line < broken[j].line
		}
		return broken[i].name < broken[j].name
	})

	var details strings.Builder
	details.WriteString("If you remove the recording rule generating `")
	details.WriteString(rule.RecordingRule.Record.Value.Value)
	details.WriteString("`, and there is no other source of this metric, then any other rule depending on it will break.\n")
	details.WriteString("List of found rules that are using `")
	details.WriteString(rule.RecordingRule.Record.Value.Value)
	details.WriteString("`:\n\n")
	for _, b := range broken {
		details.WriteString("- `")
		details.WriteString(b.name)
		details.WriteString("` at `")
		details.WriteString(b.path)
		details.WriteRune(':')
		details.WriteString(strconv.Itoa(b.line))
		details.WriteString("`\n")
	}

	problems = append(problems, Problem{
		Fragment: fmt.Sprintf("%s: %s", rule.RecordingRule.Record.Key.Value, rule.RecordingRule.Record.Value.Value),
		Anchor:   AnchorBefore,
		Lines:    rule.Lines(),
		Reporter: c.Reporter(),
		Text:     fmt.Sprintf("Metric generated by this rule is used by %d other rule(s).", len(broken)),
		Details:  details.String(),
		Severity: Warning,
	})

	return problems
}

func (c RuleDependencyCheck) usesVector(entry discovery.Entry, name string) bool {
	expr := entry.Rule.Expr()
	if expr.SyntaxError != nil {
		return false
	}

	for _, vs := range utils.HasVectorSelector(expr.Query) {
		if vs.Name == name {
			return true
		}
	}

	return false
}

type brokenDependency struct {
	path string
	name string
	line int
}
