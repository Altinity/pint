package checks

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/cloudflare/pint/internal/discovery"
	"github.com/cloudflare/pint/internal/parser"
	"github.com/cloudflare/pint/internal/parser/utils"

	"github.com/prometheus/prometheus/model/labels"
)

const (
	RuleDependencyCheckName = "rule/dependency"
)

func NewRuleDependencyCheck() RuleDependencyCheck {
	return RuleDependencyCheck{}
}

type RuleDependencyCheck struct{}

func (c RuleDependencyCheck) Meta() CheckMeta {
	return CheckMeta{
		States: []discovery.ChangeType{
			discovery.Removed,
		},
		IsOnline: false,
	}
}

func (c RuleDependencyCheck) String() string {
	return RuleDependencyCheckName
}

func (c RuleDependencyCheck) Reporter() string {
	return RuleDependencyCheckName
}

func (c RuleDependencyCheck) Check(_ context.Context, _ string, rule parser.Rule, entries []discovery.Entry) (problems []Problem) {
	var broken []*brokenDependency
	var dep *brokenDependency
	for _, entry := range entries {
		if entry.State == discovery.Removed {
			continue
		}
		if entry.PathError != nil {
			continue
		}
		if entry.Rule.Error.Err != nil {
			continue
		}
		if rule.RecordingRule != nil {
			dep = c.usesVector(entry, rule.RecordingRule.Record.Value)
		}
		if rule.AlertingRule != nil {
			dep = c.usesAlert(entry, rule.AlertingRule.Alert.Value)
		}
		if dep != nil {
			var found bool
			for _, b := range broken {
				if b.kind == dep.kind && b.path == dep.path && b.line == dep.line && b.name == dep.name {
					found = true
					break
				}
			}
			if !found {
				broken = append(broken, dep)
			}
		}
	}

	if len(broken) == 0 {
		return problems
	}

	sort.Slice(broken, func(i, j int) bool {
		if broken[i].path != broken[j].path {
			return broken[i].path < broken[j].path
		}
		if broken[i].line != broken[j].line {
			return broken[i].line < broken[j].line
		}
		return broken[i].name < broken[j].name
	})

	var details strings.Builder
	details.WriteString("If you remove the ")
	details.WriteString(dep.kind)
	details.WriteString(" rule generating `")
	details.WriteString(dep.metric)
	details.WriteString("`, and there is no other source of this metric, then any other rule depending on it will break.\n")
	details.WriteString("List of found rules that are using `")
	details.WriteString(dep.metric)
	details.WriteString("`:\n\n")
	for _, b := range broken {
		details.WriteString("- `")
		details.WriteString(b.name)
		details.WriteString("` at `")
		details.WriteString(b.path)
		details.WriteRune(':')
		details.WriteString(strconv.Itoa(b.line))
		details.WriteString("`\n")
	}

	problems = append(problems, Problem{
		Anchor:   AnchorBefore,
		Lines:    rule.Lines,
		Reporter: c.Reporter(),
		Text:     fmt.Sprintf("Metric generated by this rule is used by %d other rule(s).", len(broken)),
		Details:  details.String(),
		Severity: Warning,
	})

	return problems
}

func (c RuleDependencyCheck) usesVector(entry discovery.Entry, name string) *brokenDependency {
	expr := entry.Rule.Expr()
	if expr.SyntaxError != nil {
		return nil
	}

	for _, vs := range utils.HasVectorSelector(expr.Query) {
		if vs.Name == name {
			return &brokenDependency{
				kind:   "recording",
				metric: name,
				path:   entry.ReportedPath,
				line:   expr.Value.Lines.First,
				name:   entry.Rule.Name(),
			}
		}
	}

	return nil
}

func (c RuleDependencyCheck) usesAlert(entry discovery.Entry, name string) *brokenDependency {
	expr := entry.Rule.Expr()
	if expr.SyntaxError != nil {
		return nil
	}

	for _, vs := range utils.HasVectorSelector(expr.Query) {
		if vs.Name != "ALERTS" && vs.Name != "ALERTS_FOR_STATE" {
			continue
		}
		for _, lm := range vs.LabelMatchers {
			if lm.Name == "alertname" && lm.Type == labels.MatchEqual && lm.Value == name {
				return &brokenDependency{
					kind:   "alerting",
					metric: vs.String(),
					path:   entry.ReportedPath,
					line:   expr.Value.Lines.First,
					name:   entry.Rule.Name(),
				}
			}
		}
	}

	return nil
}

type brokenDependency struct {
	kind   string
	metric string
	path   string
	name   string
	line   int
}
